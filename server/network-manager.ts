import http from 'node:http'
import os from 'node:os'
import isPortReachable from 'is-port-reachable'
import { detectLanIps } from './bootstrap.js'
import { detectFirewall, firewallCommands, type FirewallInfo, type FirewallPlatform } from './firewall.js'
import type { ConfigStore, NetworkSettings } from './config-store.js'
import { logger } from './logger.js'

const log = logger.child({ component: 'network-manager' })

export interface NetworkStatus {
  configured: boolean
  host: '127.0.0.1' | '0.0.0.0'
  port: number
  lanIps: string[]
  machineHostname: string
  firewall: {
    platform: FirewallPlatform
    active: boolean
    portOpen: boolean | null
    commands: string[]
    configuring: boolean
  }
  rebinding: boolean
  devMode: boolean
  devPort?: number
  accessUrl: string
}

export class NetworkManager {
  private firewallInfo: FirewallInfo | null = null
  private lanIps: string[] = []
  private lanIpsInitialized = false
  private wsHandler: {
    prepareForRebind(): void
    resumeAfterRebind(): void
    broadcast(msg: unknown): void
  } | null = null
  private rebindInFlight = false
  private pendingRebindConfig: NetworkSettings | null = null
  private firewallConfiguring = false
  private userAllowedOrigins: string[]

  constructor(
    private server: http.Server,
    private configStore: ConfigStore,
    private port: number,
    private devMode: boolean = false,
    private devPort?: number,
  ) {
    // Parse user-specified extra origins from EXTRA_ALLOWED_ORIGINS env var
    const extraEnv = process.env.EXTRA_ALLOWED_ORIGINS ?? ''
    const extraOrigins = extraEnv.split(',').map(o => o.trim()).filter(Boolean)

    if (extraOrigins.length === 0 && process.env.ALLOWED_ORIGINS) {
      // Migration: check for non-auto-generated entries in ALLOWED_ORIGINS.
      // Must populate lanIps first so auto-generated LAN entries are recognized.
      this.ensureLanIps()
      const knownPorts = [this.port]
      if (this.devMode && this.devPort) knownPorts.push(this.devPort)
      const knownHosts = ['localhost', '127.0.0.1', ...this.lanIps]
      const autoGeneratedOrigins = new Set(
        knownHosts.flatMap(host =>
          knownPorts.map(p => `http://${host}:${p}`)
        )
      )
      const legacyCustom = process.env.ALLOWED_ORIGINS
        .split(',').map(o => o.trim()).filter(Boolean)
        .filter(origin => !autoGeneratedOrigins.has(origin))
      if (legacyCustom.length > 0) {
        log.warn(
          { origins: legacyCustom },
          'ALLOWED_ORIGINS contains custom entries. These will be preserved but ' +
          'please move them to EXTRA_ALLOWED_ORIGINS (ALLOWED_ORIGINS is now auto-managed).',
        )
        this.userAllowedOrigins = legacyCustom
      } else {
        this.userAllowedOrigins = extraOrigins
      }
    } else {
      this.userAllowedOrigins = extraOrigins
    }
  }

  setWsHandler(handler: {
    prepareForRebind(): void
    resumeAfterRebind(): void
    broadcast(msg: unknown): void
  }): void {
    this.wsHandler = handler
  }

  async getStatus(): Promise<NetworkStatus> {
    const settings = await this.configStore.getSettings()
    const network = settings.network

    this.ensureLanIps()

    if (!this.firewallInfo) {
      this.firewallInfo = await detectFirewall()
    }

    const ports = this.getRelevantPorts()

    // Use the actual server bind address, not the config value. On WSL2
    // the server binds to 0.0.0.0 regardless of config (for Windows host
    // access), so the config value may not reflect the real bind state.
    const addr = this.server.address()
    const actualHost = (addr && typeof addr === 'object') ? addr.address : null
    const effectiveHost: '127.0.0.1' | '0.0.0.0' =
      actualHost === '0.0.0.0' || actualHost === '::' ? '0.0.0.0'
      : actualHost === '127.0.0.1' || actualHost === '::1' ? '127.0.0.1'
      // Server not yet listening — fall back to config-based logic
      : (!network.configured && (process.env.HOST === '0.0.0.0' || process.env.HOST === '127.0.0.1'))
        ? process.env.HOST as '127.0.0.1' | '0.0.0.0'
        : network.host

    const probePort = this.devMode && this.devPort ? this.devPort : this.port
    let portOpen: boolean | null = null
    if (effectiveHost === '0.0.0.0' && this.lanIps.length > 0) {
      try {
        portOpen = await isPortReachable(probePort, { host: this.lanIps[0], timeout: 2000 })
      } catch {
        portOpen = null
      }
    }

    const commands = this.firewallInfo.active
      ? firewallCommands(this.firewallInfo.platform, ports)
      : []

    const token = process.env.AUTH_TOKEN ?? ''
    const accessHost = effectiveHost === '0.0.0.0'
      ? (this.lanIps[0] ?? 'localhost')
      : 'localhost'
    const accessPort = this.devMode && this.devPort ? this.devPort : this.port
    const accessUrl = `http://${accessHost}:${accessPort}/?token=${encodeURIComponent(token)}`

    return {
      configured: network.configured,
      host: effectiveHost,
      port: this.port,
      lanIps: this.lanIps,
      machineHostname: os.hostname().replace(/\.local$/, ''),
      firewall: {
        platform: this.firewallInfo.platform,
        active: this.firewallInfo.active,
        portOpen,
        commands,
        configuring: this.firewallConfiguring,
      },
      rebinding: this.rebindInFlight,
      devMode: this.devMode,
      devPort: this.devPort,
      accessUrl,
    }
  }

  async configure(network: NetworkSettings): Promise<{ rebindScheduled: boolean }> {
    // Use the actual server bind address to detect host changes. On WSL2
    // the server starts on 0.0.0.0 regardless of config, so comparing
    // against the config value would cause spurious rebinds.
    const addr = this.server.address()
    const actualHost = (addr && typeof addr === 'object') ? addr.address : null
    const effectiveCurrentHost =
      actualHost === '0.0.0.0' || actualHost === '::' ? '0.0.0.0'
      : actualHost === '127.0.0.1' || actualHost === '::1' ? '127.0.0.1'
      : null
    // Only rebind if we can determine the current host AND it differs
    const hostChanged = effectiveCurrentHost !== null && effectiveCurrentHost !== network.host

    await this.configStore.patchSettings({ network })

    this.firewallInfo = null
    this.refreshLanIps()
    await this.rebuildAllowedOrigins()

    if (hostChanged && this.server.listening) {
      if (this.rebindInFlight) {
        log.warn({ host: network.host }, 'Rebind in flight, queuing configure')
        this.pendingRebindConfig = network
        return { rebindScheduled: true }
      }
      this.rebindInFlight = true
      setImmediate(() => {
        this.rebind(network.host).catch((err) => {
          log.error({ err }, 'Hot rebind failed')
        })
      })
      return { rebindScheduled: true }
    }

    return { rebindScheduled: false }
  }

  async initializeFromStartup(
    _effectiveHost: '127.0.0.1' | '0.0.0.0',
    _network: NetworkSettings,
  ): Promise<void> {
    this.refreshLanIps()
    await this.rebuildAllowedOrigins()
  }

  private async rebind(host: string): Promise<void> {
    if (!this.rebindInFlight) {
      log.error({ host }, 'rebind() called without rebindInFlight set')
      this.rebindInFlight = true
    }

    const addr = this.server.address()
    const oldHost = (addr && typeof addr === 'object') ? addr.address : '127.0.0.1'

    log.info({ host, port: this.port, oldHost }, 'Hot rebinding server')

    if (this.wsHandler) {
      log.info('Preparing WsHandler for rebind')
      this.wsHandler.prepareForRebind()
    }

    try {
      await new Promise<void>((resolve, reject) => {
        this.server.close((err) => {
          if (err) {
            log.error({ err }, 'Failed to close server for rebind')
            reject(err)
            return
          }

          const onListenError = (listenErr: Error) => {
            log.error({ err: listenErr, host }, 'Failed to rebind server to new host')

            const onRollbackError = (rollbackErr: Error) => {
              log.error(
                { err: rollbackErr, originalErr: listenErr, oldHost, port: this.port },
                'CATASTROPHIC: Rollback bind also failed — server has no active listener',
              )
              reject(listenErr)
            }
            this.server.once('error', onRollbackError)
            this.server.listen(this.port, oldHost, async () => {
              this.server.removeListener('error', onRollbackError)
              log.warn({ oldHost, port: this.port }, 'Rolled back to previous bind address')

              try {
                await this.configStore.patchSettings({
                  network: { host: oldHost as '127.0.0.1' | '0.0.0.0' },
                } as any)
                await this.rebuildAllowedOrigins()
                if (this.wsHandler) {
                  const correctedSettings = await this.configStore.getSettings()
                  this.wsHandler.broadcast({
                    type: 'settings.updated',
                    settings: correctedSettings,
                  })
                }
              } catch (patchErr) {
                log.error({ err: patchErr }, 'Failed to revert config/origins after rebind failure')
              }
              reject(listenErr)
            })
          }
          this.server.once('error', onListenError)

          this.server.listen(this.port, host, () => {
            this.server.removeListener('error', onListenError)
            log.info({ host, port: this.port }, 'Server rebound successfully')
            resolve()
          })
        })
      })
    } finally {
      if (this.wsHandler) {
        this.wsHandler.resumeAfterRebind()
        log.info('WsHandler resumed after rebind')
      }
      this.rebindInFlight = false

      const queuedConfig = this.pendingRebindConfig
      this.pendingRebindConfig = null
      if (queuedConfig !== null) {
        log.info({ host: queuedConfig.host }, 'Processing queued configure')
        setImmediate(() => {
          this.configure(queuedConfig).catch((err) => {
            log.error({ err }, 'Queued configure failed')
          })
        })
      }
    }
  }

  resetFirewallCache(): void {
    this.firewallInfo = null
  }

  setFirewallConfiguring(configuring: boolean): void {
    this.firewallConfiguring = configuring
  }

  getRelevantPorts(): number[] {
    const ports = [this.port]
    if (this.devMode && this.devPort && this.devPort !== this.port) {
      ports.push(this.devPort)
    }
    return ports
  }

  private ensureLanIps(): void {
    if (!this.lanIpsInitialized) {
      this.refreshLanIps()
      this.lanIpsInitialized = true
    }
  }

  private refreshLanIps(): void {
    try {
      this.lanIps = detectLanIps()
    } catch {
      this.lanIps = []
    }
  }

  private buildAllowedOrigins(network: NetworkSettings): string[] {
    const userOrigins = this.userAllowedOrigins ?? []

    // Use the EFFECTIVE host (accounting for HOST env override when unconfigured),
    // not just the config host. This prevents a mismatch where the server binds to
    // 0.0.0.0 (via HOST env) but origins only include localhost.
    const effectiveHost = (!network.configured && (process.env.HOST === '0.0.0.0' || process.env.HOST === '127.0.0.1'))
      ? process.env.HOST
      : network.host

    // Always include loopback origins with explicit ports (both localhost and 127.0.0.1).
    const origins = [
      ...userOrigins,
      `http://localhost:${this.port}`,
      `http://127.0.0.1:${this.port}`,
    ]
    if (this.devPort) {
      origins.push(`http://localhost:${this.devPort}`)
      origins.push(`http://127.0.0.1:${this.devPort}`)
    }
    if (effectiveHost === '0.0.0.0' && this.lanIps.length > 0) {
      for (const ip of this.lanIps) {
        origins.push(`http://${ip}:${this.port}`)
        if (this.devPort) origins.push(`http://${ip}:${this.devPort}`)
      }
    }
    return [...new Set(origins)]
  }

  async rebuildAllowedOrigins(): Promise<void> {
    try {
      const settings = await this.configStore.getSettings()
      const origins = this.buildAllowedOrigins(settings.network)
      process.env.ALLOWED_ORIGINS = origins.join(',')
    } catch (err) {
      log.error({ err }, 'Failed to rebuild ALLOWED_ORIGINS')
    }
  }

  async stop(): Promise<void> {
    // No-op; retained for interface compatibility
  }
}
